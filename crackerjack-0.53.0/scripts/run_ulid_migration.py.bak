#!/usr/bin/env python3
"""ULID Migration Runner for Crackerjack - FINAL VERSION.

Uses direct SQLite connections for ULID backfill.
"""

import asyncio
import sqlite3
import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import ULID generation functions
from crackerjack.services.ulid_generator import generate_ulid, is_valid_ulid


def get_db_path():
    """Get Crackerjack database path."""
    db_dir = Path.home() / ".cache" / "crackerjack"
    return db_dir / "metrics.db"


def backfill_jobs(conn: sqlite3.Connection):
    """Backfill ULIDs for existing jobs."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM jobs WHERE job_ulid IS NULL"
    )
    job_ids = cursor.fetchall()

    for (job_id,) in job_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE jobs SET job_ulid = ?, job_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, job_id)
        )

    conn.commit()
    return len(job_ids)


def backfill_errors(conn: sqlite3.Connection):
    """Backfill ULIDs for existing errors."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM errors WHERE error_ulid IS NULL"
    )
    error_ids = cursor.fetchall()

    for (error_id,) in error_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE errors SET error_ulid = ?, error_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, error_id)
        )

    conn.commit()
    return len(error_ids)


def backfill_hook_executions(conn: sqlite3.Connection):
    """Backfill ULIDs for existing hook executions."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM hook_executions WHERE hook_ulid IS NULL"
    )
    hook_ids = cursor.fetchall()

    for (hook_id,) in hook_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE hook_executions SET hook_ulid = ?, hook_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, hook_id)
        )

    conn.commit()
    return len(hook_ids)


def backfill_test_executions(conn: sqlite3.Connection):
    """Backfill ULIDs for existing test executions."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM test_executions WHERE test_ulid IS NULL"
    )
    test_ids = cursor.fetchall()

    for (test_id,) in test_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE test_executions SET test_ulid = ?, test_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, test_id)
        )

    conn.commit()
    return len(test_ids)


def backfill_individual_tests(conn: sqlite3.Connection):
    """Backfill ULIDs for existing individual test executions."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM individual_test_executions WHERE test_execution_ulid IS NULL"
    )
    test_ids = cursor.fetchall()

    for (test_id,) in test_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE individual_test_executions SET test_execution_ulid = ?, test_execution_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, test_id)
        )

    conn.commit()
    return len(test_ids)


def backfill_strategy_decisions(conn: sqlite3.Connection):
    """Backfill ULIDs for existing strategy decisions."""
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id FROM strategy_decisions WHERE decision_ulid IS NULL"
    )
    decision_ids = cursor.fetchall()

    for (decision_id,) in decision_ids:
        ulid = generate_ulid()
        cursor.execute(
            "UPDATE strategy_decisions SET decision_ulid = ?, decision_ulid_generated_at = datetime('now') WHERE id = ?",
            (ulid, decision_id)
        )

    conn.commit()
    return len(decision_ids)


def run_migration():
    """Run ULID migration for Crackerjack."""

    print("=" * 60)
    print("Crackerjack ULID Migration")
    print("=" * 60)
    print()
    print("üìä Phase 1: Expanding Schema")
    print("   (Skipping - SQL migration already applied)")
    print()
    print("üìä Phase 2: Backfilling ULIDs")
    print("   Generating ULIDs for existing records...")

    db_path = get_db_path()

    if not db_path.exists():
        print(f"   ‚ö†Ô∏è  Database not found at {db_path}")
        print("   No migration needed - database doesn't exist yet")
        return

    # Connect to database
    conn = sqlite3.connect(str(db_path))

    try:
        # Backfill all tables
        jobs_count = backfill_jobs(conn)
        print(f"   ‚úÖ Jobs backfilled: {jobs_count} records")

        errors_count = backfill_errors(conn)
        print(f"   ‚úÖ Errors backfilled: {errors_count} records")

        hooks_count = backfill_hook_executions(conn)
        print(f"   ‚úÖ Hook executions backfilled: {hooks_count} records")

        tests_count = backfill_test_executions(conn)
        print(f"   ‚úÖ Test executions backfilled: {tests_count} records")

        individual_tests_count = backfill_individual_tests(conn)
        print(f"   ‚úÖ Individual tests backfilled: {individual_tests_count} records")

        decisions_count = backfill_strategy_decisions(conn)
        print(f"   ‚úÖ Strategy decisions backfilled: {decisions_count} records")

        total = (jobs_count + errors_count + hooks_count +
                  tests_count + individual_tests_count + decisions_count)

        print()
        print("üéâ Migration Complete!")
        print(f"   Total records migrated: {total} records across 6 tables")
        print()
        print("‚è≠Ô∏è  Next Steps:")
        print("   1. Application code updated to use ULID for new records")
        print("   2. Verification period: 14 days (keep both IDs active)")
        print("   3. After verification, can switch to ULID as primary identifier")
        print()

    finally:
        conn.close()


if __name__ == "__main__":
    run_migration()
