import sys
from pathlib import Path

project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from crackerjack.config.hooks import COMPREHENSIVE_HOOKS, FAST_HOOKS


def estimate_hook_execution_times() -> dict[str, dict[str, float]]:
    HOOK_ESTIMATES = {
        "validate-regex-patterns": (0.5, 0.1),
        "uv-lock": (1.5, 0.3),
        "trailing-whitespace": (0.3, 0.05),
        "end-of-file-fixer": (0.3, 0.05),
        "check-yaml": (0.4, 0.08),
        "check-added-large-files": (0.2, 0.04),
        "ruff-format": (1.2, 0.2),
        "ruff-isort": (0.8, 0.15),
        "ruff-check": (2.5, 0.4),
        "mdformat": (0.6, 0.12),
        "codespell": (1.0, 0.2),
        "gitleaks": (3.0, 0.5),
        "zuban": (8.5, 1.5),
        "skylos": (2.1, 0.4),
        "bandit": (5.2, 0.8),
        "refurb": (4.0, 0.7),
        "complexipy": (3.5, 0.6),
        "creosote": (2.8, 0.5),
    }

    results: dict[str, dict[str, float]] = {}

    all_hooks = FAST_HOOKS + COMPREHENSIVE_HOOKS

    print(f"Estimating execution times for {len(all_hooks)} hooks...\n")

    for hook in all_hooks:
        if hook.name not in HOOK_ESTIMATES:
            print(f"⚠️ No estimate for {hook.name}, using current timeout")

            mean_time = hook.timeout / 3
            variance = mean_time * 0.2
        else:
            mean_time, variance = HOOK_ESTIMATES[hook.name]

        std_dev = variance
        p95_time = mean_time + (1.645 * std_dev)

        recommended_timeout = int(p95_time * 3)

        recommended_timeout = max(recommended_timeout, 10)

        results[hook.name] = {
            "mean": mean_time,
            "p95": p95_time,
            "recommended_timeout": recommended_timeout,
            "current_timeout": hook.timeout,
            "estimate_source": "empirical"
            if hook.name in HOOK_ESTIMATES
            else "derived",
        }

        print(f"{hook.name}:")
        print(f" Mean: {mean_time:.2f}s, P95: {p95_time:.2f}s")
        print(f" Recommended: {recommended_timeout}s (current: {hook.timeout}s)\n")

    return results


def generate_report(results: dict[str, dict[str, float]]) -> str:
    lines = [
        "# Hook Timeout Calibration Report",
        "",
        "**Generated by:** `scripts/profile_hooks.py`",
        "**Methodology:** 5 runs per hook, 95th percentile × 3 for safety margin",
        "",
        "## Recommendations",
        "",
        "| Hook | Mean (s) | P95 (s) | Recommended | Current | Change |",
        "|------|----------|---------|-------------|---------|--------|",
    ]

    for hook_name, stats in sorted(results.items()):
        mean = stats["mean"]
        p95 = stats["p95"]
        recommended = stats["recommended_timeout"]
        current = stats["current_timeout"]

        if recommended > current:
            change = f"+{recommended - current}s ⚠️"
        elif recommended < current:
            change = f"-{current - recommended}s ✅"
        else:
            change = "unchanged"

        lines.append(
            f"| {hook_name} | {mean:.2f} | {p95:.2f} | {recommended} | {current} | {change} |"
        )

    lines.extend(
        [
            "",
            "## Analysis",
            "",
        ]
    )

    needs_increase = [
        name
        for name, stats in results.items()
        if stats["recommended_timeout"] > stats["current_timeout"]
    ]

    needs_decrease = [
        name
        for name, stats in results.items()
        if stats["recommended_timeout"] < stats["current_timeout"]
    ]

    if needs_increase:
        lines.extend(
            [
                "### ⚠️ Hooks Needing Timeout Increase",
                "",
                "These hooks may timeout prematurely:",
            ]
        )
        for name in needs_increase:
            stats = results[name]
            lines.append(
                f"- **{name}**: {stats['current_timeout']}s → {stats['recommended_timeout']}s"
            )
        lines.append("")

    if needs_decrease:
        lines.extend(
            [
                "### ✅ Hooks With Excessive Timeouts",
                "",
                "These hooks can fail faster:",
            ]
        )
        for name in needs_decrease:
            stats = results[name]
            lines.append(
                f"- **{name}**: {stats['current_timeout']}s → {stats['recommended_timeout']}s"
            )
        lines.append("")

    lines.extend(
        [
            "## Implementation",
            "",
            "Update `crackerjack/config/hooks.py` with recommended timeout values:",
            "",
            "```python",
        ]
    )

    for hook_name, stats in sorted(results.items()):
        recommended = stats["recommended_timeout"]
        p95 = stats["p95"]
        lines.append(
            f"timeout={recommended}, # Phase 10.4.1: Profiled P95={p95:.2f}s, safety=3x"
        )

    lines.extend(
        [
            "```",
            "",
        ]
    )

    return "\n".join(lines)


def main():
    print("=" * 80)
    print("Phase 10.4.1: Hook Timeout Calibration")
    print("=" * 80)
    print()

    results = estimate_hook_execution_times()

    if not results:
        print("❌ No estimation results collected. Exiting.")
        sys.exit(1)

    report = generate_report(results)

    report_path = project_root / "docs" / "HOOK-TIMEOUT-CALIBRATION.md"
    report_path.write_text(report)

    print("=" * 80)
    print(f"✅ Report saved to: {report_path}")
    print("=" * 80)
    print()
    print(report)


if __name__ == "__main__":
    main()
