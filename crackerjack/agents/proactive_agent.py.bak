import typing as t

from .base import AgentContext, FixResult, Issue, IssueType, SubAgent
from .file_context import FileContextReader
from .syntax_validator import SyntaxValidator
from .syntax_validator import SyntaxValidator


class ProactiveAgent(SubAgent):
    MAX_DIFF_LINES = 50

    def __init__(self, context: AgentContext) -> None:
        super().__init__(context)
        self._planning_cache: dict[str, dict[str, t.Any]] = {}
        self._pattern_cache: dict[str, t.Any] = {}
        self._file_reader = FileContextReader()
        self._syntax_validator = SyntaxValidator()
        self._syntax_validator = SyntaxValidator()

        self._type_specific_confidence: dict[str, float] = {
            "refurb": 0.85,
            "type_error": 0.75,

            success=True,
            confidence=0.5,
            fixes_applied=[],
            remaining_issues=[],
        )

    async def _read_file_context(self, file_path: str) -> str:
        """Read file context with caching - MANDATORY before _generate_fix()."""
        return await self._file_reader.read_file(file_path)
        cache_key = self._get_planning_cache_key(issue)
        if cache_key in self._planning_cache:
            plan = self._planning_cache[cache_key]
            self.log(f"Using cached plan for {cache_key}")
        else:
            plan = await self.plan_before_action(issue)
            self._planning_cache[cache_key] = plan

        result = await self.execute_with_plan(issue, plan)

        if result.success and result.confidence >= 0.8:
            self._cache_successful_pattern(issue, plan, result)
        return result

    def _get_planning_cache_key(self, issue: Issue) -> str:
        return f"{issue.type.value}: {issue.file_path}: {issue.line_number}"

    def _cache_successful_pattern(
        self,
        issue: Issue,
        plan: dict[str, t.Any],
        result: FixResult,
    ) -> None:
        pattern_key = f"{issue.type.value}_{plan.get('strategy', 'default')}"
        self._pattern_cache[pattern_key] = {
            "plan": plan,
            "confidence": result.confidence,
            "files_modified": result.files_modified,
            "fixes_applied": result.fixes_applied,
        }
        self.log(f"Cached successful pattern: {pattern_key}")

    def get_cached_patterns(self) -> dict[str, t.Any]:
        return self._pattern_cache.copy()

    def get_planning_confidence(self, issue: Issue) -> float:

        if issue.type in self._type_specific_confidence:
            return self._type_specific_confidence[issue.type]

        pattern_prefix = f"{issue.type.value}_"
        confidences = [
            t.cast("float", pattern.get("confidence", 0.0))
            for key, pattern in self._pattern_cache.items()
            if key.startswith(pattern_prefix)
        ]

        if not confidences:
            return 0.5
        return max(confidences)

    def get_supported_types(self) -> set[IssueType]:
        return {
            IssueType.FORMATTING,
            IssueType.TYPE_ERROR,
            IssueType.REFURB,
            IssueType.COMPLEXITY,
            IssueType.SECURITY,
            IssueType.IMPORT_ERROR,
        }

    async def _read_file_context(self, file_path: str) -> str:
        """
        Read full file context before generating fix.

        This is MANDATORY before any code generation to ensure
        agents have complete context.

        Args:
            file_path: Path to file to read

        Returns:
            File content as string

        Raises:
            FileNotFoundError: If file doesn't exist
            IOError: If file cannot be read
        """
        self.log(f"Reading file context: {file_path}")
        content = await self._file_reader.read_file(file_path)
        self.log(f"Read {len(content)} characters from {file_path}")
        return content

    def _validate_diff_size(self, old_code: str, new_code: str) -> bool:
        """
        Validate that diff size is within acceptable limits.

        Prevents agents from making massive, risky changes.

        Args:
            old_code: Original code
            new_code: New code

        Returns:
            True if diff size is acceptable
        """
        old_lines = old_code.count("\n")
        new_lines = new_code.count("\n")

        diff_lines = abs(new_lines - old_lines)

        if diff_lines > self.MAX_DIFF_LINES:
            self.log(
                f"Diff too large: {diff_lines} lines (max: {self.MAX_DIFF_LINES})",
                level="WARNING",
            )
            return False

        self.log(f"Diff size OK: {diff_lines} lines")
        return True

    async def _validate_syntax(
        self, code: str, file_path: str | None = None
    ) -> tuple[bool, list[str]]:
        """
        Validate Python syntax using AST parsing.

        Args:
            code: Code to validate
            file_path: Optional file path for error reporting

        Returns:
            Tuple of (is_valid, error_messages)
        """
        result = await self._syntax_validator.validate(code)
        return result.valid, result.errors
